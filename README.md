[English](#english) | [日本語](#japanese)

&nbsp;
&nbsp;

<a id="english"></a>

# Project Name (English)

_This Project has been created as part of the 42 curriculum by yuonishi_

## Table of Contents
1. [Description](#description)
2. [Project Description](#project-description)
3. [Resources](#resources)
...

## Description
(English content...)

&nbsp;  
&nbsp;  

---













<a id="japanese"></a>

# Project Name (Japanese)

_This Project has been created as part of the 42 curriculum by yuonishi_

## 目次
1. [概要](#概要)
2. [プロジェクト詳細](#プロジェクト詳細)
3. [使い方](#使い方)
3. [参考文献](#参考文献)



&nbsp;  
&nbsp;  



## 概要
当課題では、決められたコマンドを用い、スタック内をソートする。  
その際、可能な限り少ない操作回数でのソートを行うことが、最大の目的である。

## この課題で学ぶべきこと
### 1. **計算量の意識**  
普通にソートするのであれば、バブルソート等で済む。しかし、それでは手数が増えてしまう。  
よって、「動けばいい」ではなく、「効率的であること」が求められる。「どうすれば無駄な動きを削減できるか」の意識が重要だ。  
また、既存のソート法の中から、適切な処理を選定する必要がある。
### 2. **制約のある環境下でのアルゴリズム実装**  
普段であれば、「配列の何番と何番を交換」を一瞬で行えるが、今回のデータ構造では、一番上のデータしか触れない（FIFO）という制約がある。  
この不自由な環境下での、どうアルゴリズムを実装するか、という力が求められる。
### 3. **データ構造の実践的な操作**
スタックの構造を、実際のプログラムとして動かし、データを スタックA ⇔ スタックB と移動させる処理を実装する力が求められる。



&nbsp;  
&nbsp;  



## プロジェクト概要
この課題では、スタックAにあるデータを、スタックBを一時領域として利用し、「限られた命令セット」のみを使用してソートするプログラムを作成する。  
重要な点は、ソート完了までに出力される「命令回数の最小化」である。

## データ構造の技術選定：双方向連結リスト vs リングバッファ
本プロジェクトでは、スタックの柔軟な操作を考慮し、双方向連結リストを採用した。

### データ構造比較表
---
| 比較項目 | **リングバッファ（循環配列）** | **双方向リスト** |
| :--- | :--- | :--- |
| **アクセス速度** | 非常に高速`O(1)`。<br>インデックスで即座にアクセス可能。キャッシュ効率が良い。 | 低速`O(n)`。<br>特定の要素へはポインタを順に辿る必要がある。 |
| **push・pop** | 高速だが制約あり`O(1)`。<br>Topインデックスを増減させるだけ<br>端（Top/Bottom）なら速いが、中間操作はシフトが発生。| 非常に高速`O(1)`。<br>ポインタの付け替えのみ。中間挿入もポインタ保持で容易。|
| **メモリ効率** | **静的確保（固定長）**<br>事前に最大数確保するため、未使用領域が発生。 | **動的確保（可変長）**<br>必要な時にノードを生成。無駄な領域が発生しない。 |
| **実装の課題** | **インデックス計算**<br>`0`と`MAX`の境界を超える際の剰余演算が複雑。 | **ポインタ管理**<br>NULL参照防止や、malloc/freeによるメモリ管理 |
| **学習の狙い** | 配列操作、メモリ効率 | ポインタ操作、構造体（リスト操作）、メモリ管理 |
---
### 選定理由

### 1. データ移動の適性
`push_swap` の本質は、スタック間でのデータの受け渡し（`pa`, `pb`）と、要素の回転（`ra`, `rra`）である。
- **リストの利点**:  
リストは、ポインタをいくつか書き換えるだけで挿入・削除が完了する。要素が100個、500個と増えても、ポインタの繋ぎ変え（`next`, `pre`）の処理時間は一定`O(1)`。
- **配列の欠点**:  
通常の配列では要素のズラし作業が発生するが、リングバッファや実装次第では可能（キャッシュでtopやsizeを保持）。しかし、スタックのサイズが動的に変化するため、最初に巨大な配列を確保する必要がある。
### 2. メモリ管理の柔軟性
- リストでは、動的に拡張領域を変更でき、無駄な領域が発生しない。
- 実際に当課題でも、`make_node` により必要な要素分だけ `malloc` し、`free_stack` で一括解放する設計にしている。これにより、実行時の引数の数に依存しない柔軟なメモリ使用が可能。

### 3. 走査コスト
当課題で実装したアルゴリズム（Greedy）では、スタック内の全要素を走査し、最もコストの低い移動数を計算する。  
リストは先頭から辿るため走査に`O(n)`かかってしまう。しかし、`push_swap` における条件は「命令回数（手数）」であり、プログラム自体の実行速度（CPUサイクル）ではない。そのため、アクセス速度よりも、構造の変更（ポインタの繋ぎ変え）が直感的であり、ミスが起きにくいリスト構造のほうが向いていると考える。

### 結論
「配列（リングバッファ）の方がキャッシュ効率が良く、read/writeが最小限で済む」という利点はありますが、本課題においては**ノードの追加・削除の簡便さ**と**メモリ消費の最適化**を優先し、双方向連結リストを選択しました。これにより、`pa`や`pb`といった複雑な移動操作を、セグメンテーションフォールトのリスクを抑えつつ堅牢に実装することが可能となりました。

---

### 次のステップ

READMEにこの比較表を載せる場合、**「なぜリングバッファではなくリストにしたのか」**という質問に対する回答として非常に強力なセクションになります。

もし、さらに技術的な詳細（例：なぜ単方向ではなく「双方向」にしたのか、など）を追記したい場合は、追加で構成案を作成できますが、いかがでしょうか？



























&nbsp;  
&nbsp;  

---

### 環境構築と実装方針 (Phase 1)
1. ディレクトリ構成

保守性と再利用性を高めるため、外部ライブラリを独立したディレクトリとして配置し、再帰的なビルド環境を構築した。
Plaintext

push_swap/
├── Makefile            # ルートMakefile（各ライブラリの呼び出しとリンク）
├── includes/           # プロジェクト共通ヘッダー
├── srcs/               # ソースコード
├── libft/              # Libftライブラリ（.git削除済み）
└── ft_printf/          # ft_printfライブラリ（.git削除済み）

2. Makefile設計

    再リンク防止 (Relink protection): ソース変更がない場合はコンパイルを行わない設計。

    ライブラリ統合: libft および ft_printf をサブディレクトリのMakefileに委譲 (make -C) し、生成された .a ファイルをリンク (-L -l) する構成を採用。

3. データ構造の定義 (push_swap.h)

比較実装を行うため、以下の2つの構造体を定義済み。

    t_ring: 循環バッファ用の構造体（データ配列、top/bottomインデックス、サイズ管理）。

    t_stack (t_node): 双方向リスト用の構造体（値、next/prevポインタ）。

---





### ソートの選択  
以下、「ボトムアップ型マージソート」 を push_swap で実装するための、設計書兼手順書 を作成した。

## 1. 目的とコンセプト

### 目的

- ランダムな数値の列を、O(NlogN) の計算量でソートする。
- 「すでに部分的にソートされている箇所」 を活用して、効率よく並べ替える。

### コンセプト：自然マージソート（Natural Merge Sort）

再帰（上から分割）ではなく、**「足元にある小さな山（ソート済みの列）」を見つけて、それを合体（マージ）させていく** 手法です。

> **イメージ:**
> トランプのカードがバラバラに配られました。よく見ると「3, 4, 5」とか「10, 11」みたいに、**偶然揃っている部分**がいくつかありますよね？
> それらを崩さずに利用して、最終的に全部を1つの順番にする方法です。

---

## 2. アルゴリズムの全体像（4つのフェーズ）
このアルゴリズムは、以下の繰り返しで進みます。

### Phase 1: ラン（Run）の検出と分離
スタックAを上から見ていき、「単調増加」または「単調減少」の部分を見つけて、それをひとまとめ（1つの山）として扱う。

* 例: `[1, 5, 8, 2, 4, 10]`
* 山1: `1, 5, 8`
* 山2: `2, 4, 10`



### Phase 2: 初期分配（Distribution）
見つけた「山」を、スタックBに移動させたり、スタックAに残したりして、**マージ（合体）の準備**をする。
- 奇数番目の山はBへ、偶数番目の山はAに残す、など。

### Phase 3: マージ（Merge）
スタックAの先頭にある「山」と、スタックBの先頭にある「山」を比較しながら、より大きな1つの山に統合して、別の場所（Aの底やBの底）に送る。
- `A: [1, 5]`, `B: [2, 4]` → `New: [1, 2, 4, 5]`

### Phase 4: 繰り返し
山が1つ（完全にソートされた状態）になるまで、Phase2, 3を繰り返す。

---

## 3. 実装ロードマップ（ステップバイステップ）
いきなり全部作るのは無理なのため、以下の順序で実装する。

### Step 1: 「山（Run）」を見つける機能 【今回の目標】
まずは、スタックの先頭から見て 「どこまでがソートされているか」を判定する関数を作る。
- `check_sorted_length(stack)`: 先頭から何個ソートされているか数える。

### Step 2: 2つの山をマージする機能
単純に2つのスタック（AとB）のトップを比較し、小さい順（または大きい順）に並べる機能を作る。
- これができれば、事実上ソートの核が完成する。
v
### Step 3: 全体をマージするループ
Step1で見つけた山をStep2で合体させるループを作る。

---

## 4. 構造体の確認
「今扱っている山のサイズ」などは、関数の引数（`int len`）として渡せば管理できる。

```c
typedef struct s_node
{
    int             value;
    struct s_node   *pre;
    struct s_node   *next;
}               t_node;

```

---

## 5. Step 1 の実装

まずは、「今のスタックAの先頭から、何個が連番（増加列）になっているか？」を数える関数を作る。

### 作成するファイル
`srcs/sort_algorithm/find_run.c`（名前は任意）

### 実装すべき関数のイメージ

```c
/*
 * 目的: スタックの先頭から「単調増加」している長さ(Run Length)を返す
 * 例: stack [1, 5, 8, 2, ...] -> 戻り値 3 (1, 5, 8 までが増加だから)
 * 例: stack [10, 2, ...]      -> 戻り値 1 (10の次は減ってるからここで終わり)
 */
int get_run_length(t_stack *stack)
{
    // 1. スタックが空なら 0
    // 2. 現在のノード(top)とその次(next)を比較
    // 3. (current->value < next->value) である限りカウントアップ
    // 4. カウントを返す
}
```

Step 2: マージ機能の実装

やりたいこと: 
スタックAの先頭にある「ソート済みの山（長さA）」と、スタックBの先頭にある「ソート済みの山（長さB）」を、大きさ比べしながら合体させて、スタックAの底（Bottom）に送る。

イメージ: 
トランプの「スピード」や「戦争」のように、2つの手札（AとB）の一番上を見比べて、小さい方を場（Bottom）に出していく作業です。
ロジック

関数 merge_runs(t_stack *a, t_stack *b, int len_a, int len_b)

    ループ条件: 両方の山にカードが残っている間 (len_a > 0 かつ len_b > 0) 繰り返す。

    比較:

        Case 1: Aの方が小さい場合 (A->top < B->top)

            Aのカードを底に送る (ra)。

            Aの山が1つ減ったので len_a--。

        Case 2: Bの方が小さい場合 (B->top < A->top)

            BのカードをAに持ってくる (pa)。

            持ってきたカードを底に送る (ra)。

            Bの山が1つ減ったので len_b--。

    残処理: どちらかの山が尽きたら、残っている方の山を全て底に送る。

---

# Step 3: 全体をマージするループ（ソートの実行）

## 1. 目的

`merge_len_in_a` は、あくまで「準備された2つの山」を合体させるだけの関数。
これを使ってソートを完了させるには、「スタックAにある山を、順番にBに移動させて、戦わせて、勝った方を底に送る」という作業を繰り返す必要がある。

## 2. アルゴリズムの動き

ボトムアップ・マージソートの1周（パス）は、以下の流れで行う。

1. Run A の計測: スタックAの先頭にある「ソート済みの山」の長さを測る。
2. Run B の準備: スタックAの次の「ソート済みの山」を、スタックBに移動させる。
3. Merge: AとBの山を戦わせて、合体させてAの底に送る。
4. Repeat: スタックAのTopが処理済みになるまで 1〜3 を繰り返す。

### ここで発生する「反転問題」

スタック操作の宿命として、**「AからBに移動(`pb`)すると、順序が逆になる」** という問題がある。

* A: `[1, 2, 3]` (昇順)
* `pb` 3回
* B: `[3, 2, 1]` (降順)

現在の `merge_len_in_a` は「Bも昇順（Topが最小）」であることを前提としている。
そのため、このステップでは「Bに送るときに、どうやって昇順を保つか（あるいは降順を利用するか）」がカギになる。

今回はシンプルに学ぶため、まずは「移動とマージの枠組み」を作る。

---

ココまでで以下
  yuonishi  …/Push_swap   master 
>> ARG=$(seq 1 100 | shuf | tr '\n' ' '); ./push_swap $ARG | wc -l
1746

  yuonishi  …/Push_swap   master 
>> ARG=$(seq 1 500 | shuf | tr '\n' ' '); ./push_swap $ARG | wc -l
10743

のため、最適化を行う

## 1. 挿入ソートの実装





---


ご要望にお応えし、**「自然マージソート（Natural Merge Sort）」** から始まったこのプロジェクトの変遷を、なぜその選択をし、なぜ壁にぶつかったのかが分かるように時系列でまとめました。

---

# Push_swap アルゴリズム改善の全履歴

このプロジェクトの真の敵は、計算時間ではなく**「スタック操作のコスト（特に回転）」**でした。これに気づくまでの物語です。

## 📅 Phase 1: 自然マージソート (Natural Merge Sort)

**「元々の並びを活かしたい」という直感的なスタート**

* **戦略:**
* 入力データの中に、最初からソートされている部分列（Run）を探す（例: `3, 5, 6` ... `1, 2`）。
* それらのRunをスタックBを使ってマージし、より長いRunにしていく。


* **結果:** **約 2000回以上** (N=100)
* **敗因:** **「底へのアクセス権がない」**
* マージソートは「2つの列の先頭を比較して、小さい方を**新しい列の最後尾**に置く」作業です。
* 配列なら `arr[i] = val` で一瞬ですが、スタックで「最後尾（Bottom）」に置くには、`ra`（回転）して底に送り込まなければなりません。
* 100個のデータをマージするたびに、ほぼ100回の回転が発生。これが致命的でした。



⬇️ *「マージの回数自体を減らせばいいのでは？」*

## 📅 Phase 2: TimSort / ハイブリッド挿入ソート

**「初期Runを無理やり大きくして、マージ回数を減らす」**

* **戦略:**
* 自然な並びに頼らず、最初の段階で「サイズ25〜30のソート済みブロック」を強制的に作る（挿入ソート）。
* Runの数が減るので、マージする回数（パス数）も減るはず。


* **結果:** **約 1200〜1600回** (N=100)
* **状況:**
* 確かにマージの「回数」は減った。
* しかし、挿入ソートで作ったブロックを**「マージして結合する」瞬間の回転コスト（底送り）**はどうしても消せなかった。
* `ra`（Aの回転）と `rb`（Bの回転）を個別に実行しており、無駄が多かった。



⬇️ *「マージ（整列維持）へのこだわりを捨てよう。コスト計算だ」*

## 📅 Phase 3: コスト計算型 Greedy (現在のアルゴリズム)

**「整列の美しさより、命令数の安さを優先する」**

* **戦略:**
* **分割:** ざっくりと「平均より小さいグループ」「大きいグループ」に分けてBに送る（この時点では順序は適当でいい）。
* **計算:** Bにある全ての要素について、**「今、Aの正しい位置に戻るために何手必要か？」**を全員分シミュレーションする。
* **実行:** 最も安く済む要素（MVP）だけを実際に動かす。


* **結果:** **約 580〜630回** (N=100) 🏆
* **勝因:** **「同時回転 (rr / rrr) の最大活用」**
* マージソートは構造上、`ra` と `rb` を別々に打つことが多いです（Aを回して底へ、など）。
* このアルゴリズムは、「AもBも同じ方向に回すタイミング」を狙って移動させるため、1回の命令で2つのスタックを操作でき、コストが激減しました。



---

## 📊 スコア推移と構造の比較

| アルゴリズム | 思考の重点 | N=100 命令数 | 致命的な弱点 |
| --- | --- | --- | --- |
| **1. 自然マージ** | 「データ構造の綺麗さ」 | ~2000 | 全要素を底に送るための `ra` が多すぎる |
| **2. TimSort風** | 「マージ回数の削減」 | ~1400 | Run生成コストと、結局マージ時の `ra` が残る |
| **3. コスト計算** | **「命令数の節約」** | **~600** | なし。`rr`/`rrr` をフル活用できる |

**結論:**
「マージソート」は配列操作やリンクドリストでは最強ですが、**「回転にコストがかかるスタック」においては、計算で最短手を探すGreedy法が正解**でした。私たちは遠回りしましたが、ボトルネック（回転コスト）を一つずつ潰した結果、ここに辿り着きました。


---







&nbsp;
&nbsp;

---

## 参考文献
- [うさぎでもわかる配列と連結リスト](https://www.momoyama-usagi.com/entry/info-algo-list)
- [うさぎでもわかるスタックとキュー](https://www.momoyama-usagi.com/entry/info-algo-stack-queue)
- [双方向連結リストとは](https://ufcpp.net/study/algorithm/col_blist.html)
&nbsp;  
&nbsp;  





---

### AIの使用について
本課題では、AIツール（Gemini Pro）を以下の通りで使用した。
### 使用したタスク
- 1
- 2
- 3

&nbsp;  
&nbsp;  

---

# 作業用メモ
- 参考記事：[うさぎでもわかるスタックとキュー（配列を使ったデータ構造）](https://www.momoyama-usagi.com/entry/info-algo-stack-queue)
- 
	- スタック  
		- ルール  
	  		LIFO (Last In, First Out) - 後に入れたものが先に出る。
		- 仕組み
	  		出入り口は「上 (top)」の1箇所のみ。
		- 特徴  
	  		データは消さずに top の位置をズラすだけで管理する（データは消さずに無視）。　　
		### 構造体：
		```c
		typedef struct	s_stack
		{
			int	elm[SIZE];
			int	top;
		}				t_stack;
		```
		### 動作
		```c
		void	push(t_stack *s, int x)
		{
		s->top += 1;
		s->elm[s->top] = x;
		}
		
		int		pop(t_stack *s)
		{
			int	out_data;

			out_data = s->elm[s->top];
			s->top -= 1;
			return (out_data);
		}
		```
	  - 実用例  
	  ChromeやFirefoxの「戻るボタン」がスタック。戻るボタンを押すと直前のページへ移動し、更に連打するとより古い履歴に遡っていく。	
	- キュー  
		- ルール  
	  		FIFO (First In, First Out) - 先に入れたものが先に出る。
		- 仕組み
	  		出入り口は「入口 (end)」と「出口 (start)」の2箇所。
		- 特徴  
	  		配列の端まで来たら、% SIZE で先頭に戻る（環状、リングキュー）。  
			start と end が重なると「空」かどうか区別できないため、count で個数を数える。
		### 構造体：
		```c
		typedef struct	s_queue
		{
			int	elm[SIZE];
			int	start;
			int	end;
			int	count;
		}				t_queue;
		```
		### 動作
		```c
		int	nextStep(int x)
		{
			return ((x + 1) % SIZE);
		}

		void	enqueue(t_queue *q, int x)
		{
			q->elm[q->end] = x;
			q->end = nextStep(q->end);
			q->count++;
		}

		int	dequeue(t_queue *q)
		{
			int	out_data;

			out_data = q->elm[q->start];
			q->start = nextStep(q->start);
			q->count--;
			return (out_data);
		}
		```
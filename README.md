[English](#english) | [日本語](#japanese)

&nbsp;
&nbsp;

<a id="english"></a>

# Project Name (English)

_This Project has been created as part of the 42 curriculum by yuonishi_

## Table of Contents
1. [Description](#description)
2. [Project Description](#project-description)
3. [Resources](#resources)
...

## Description
(English content...)

&nbsp;  
&nbsp;  

---













<a id="japanese"></a>

# Project Name (Japanese)

_This Project has been created as part of the 42 curriculum by yuonishi_

## 目次
1. [概要](#概要)
2. [プロジェクト詳細](#プロジェクト詳細)
3. [使い方](#使い方)
3. [参考文献](#参考文献)

&nbsp;  
&nbsp;  

---

## 概要
当課題での目的は、決められたコマンドのみを用い、スタック内をソートすること。その際、可能な限り少ない操作回数でのソートを目指す。

この課題で学ぶべきこと
1. 計算量の意識  
- 普通にソートするのであれば、バブルソート等で済むが、それだと手数が増えてしまう。
- 「動けばいい」ではなく、「効率的であること」が求められる。「どうすれば無駄な動きを削減できるか」を意識する
2. 制約のある環境下でのアルゴリズム実装
- 普段であれば、「配列の何番と何番を交換」を一瞬でできるが、スタック構造では、一番上のデータしか触れない（LIFO）という制約がある。
- この不自由な環境下での、どうアルゴリズムを実装するか、という力が求められる。
3. データ構造の実践的な操作
- スタックの構造を、実際のプログラムとして動かし、データを スタックA ⇔ スタックB と移動させる処理を実装する力が求められる。

&nbsp;  
&nbsp;  

---

## プロジェクト概要
この課題では、スタックAにあるデータを、スタックBを一時領域として利用し、「限られた命令セット」のみを使用してソートするプログラムを作成する。重要な点は、ソート完了までに出力される「命令回数の最小化」である。
### データ構造の選定
ra (Rotate A) や rra (Reverse Rotate A) 等の命令は、スタックのbottomデータとtopにあるデータを操作する。このため、適切なデータ構造を選ばなければ計算コストや実装の複雑さが跳ね上がる。

&nbsp;  
&nbsp;  

---

### データ構造比較：リンクリスト vs 配列
ここでは、「リングバッファ」と「双方向リスト」を比較する。
| 比較項目 | **A. リングバッファ（循環配列）** | **B. 双方向リスト（Doubly Linked List）** |
| :--- | :--- | :--- |
| **メモリ管理** | 静的/一括確保 (`malloc` 1回)<br>メモリが連続しておりキャッシュ効率が良い。 | 動的確保 (ノード毎に `malloc`)<br>メモリが分散するため管理が必要。 |
| **Push/Pop** | Topインデックスを増減させるだけ。 | ポインタの付け替えのみ。 |
| **Rotate (`ra`)** | Top/Bottomのインデックスをズラす。<br>(中身のコピーは発生しない) | 先頭と末尾のポインタを繋ぎ変える。 |
| **実装の難所** | **インデックス計算**<br>`0`と`MAX`の境界を超える際の剰余演算 (`%`) が複雑。 | **ポインタ管理**<br>`next`, `prev` の消失やNULL参照によるセグフォ。 |
| **学習の狙い** | 配列操作、メモリ効率 | ポインタ操作、構造体、メモリ管理の基礎 |

&nbsp;  
&nbsp;  

---

### 環境構築と実装方針 (Phase 1)
1. ディレクトリ構成

保守性と再利用性を高めるため、外部ライブラリを独立したディレクトリとして配置し、再帰的なビルド環境を構築した。
Plaintext

push_swap/
├── Makefile            # ルートMakefile（各ライブラリの呼び出しとリンク）
├── includes/           # プロジェクト共通ヘッダー
├── srcs/               # ソースコード
├── libft/              # Libftライブラリ（.git削除済み）
└── ft_printf/          # ft_printfライブラリ（.git削除済み）

2. Makefile設計

    再リンク防止 (Relink protection): ソース変更がない場合はコンパイルを行わない設計。

    ライブラリ統合: libft および ft_printf をサブディレクトリのMakefileに委譲 (make -C) し、生成された .a ファイルをリンク (-L -l) する構成を採用。

3. データ構造の定義 (push_swap.h)

比較実装を行うため、以下の2つの構造体を定義済み。

    t_ring: 循環バッファ用の構造体（データ配列、top/bottomインデックス、サイズ管理）。

    t_stack (t_node): 双方向リスト用の構造体（値、next/prevポインタ）。

---





### ソートの選択  
以下、「ボトムアップ型マージソート」 を push_swap で実装するための、設計書兼手順書 を作成した。

## 1. 目的とコンセプト

### 目的

- ランダムな数値の列を、O(NlogN) の計算量でソートする。
- 「すでに部分的にソートされている箇所」 を活用して、効率よく並べ替える。

### コンセプト：自然マージソート（Natural Merge Sort）

再帰（上から分割）ではなく、**「足元にある小さな山（ソート済みの列）」を見つけて、それを合体（マージ）させていく** 手法です。

> **イメージ:**
> トランプのカードがバラバラに配られました。よく見ると「3, 4, 5」とか「10, 11」みたいに、**偶然揃っている部分**がいくつかありますよね？
> それらを崩さずに利用して、最終的に全部を1つの順番にする方法です。

---

## 2. アルゴリズムの全体像（4つのフェーズ）
このアルゴリズムは、以下の繰り返しで進みます。

### Phase 1: ラン（Run）の検出と分離
スタックAを上から見ていき、「単調増加」または「単調減少」の部分を見つけて、それをひとまとめ（1つの山）として扱う。

* 例: `[1, 5, 8, 2, 4, 10]`
* 山1: `1, 5, 8`
* 山2: `2, 4, 10`



### Phase 2: 初期分配（Distribution）
見つけた「山」を、スタックBに移動させたり、スタックAに残したりして、**マージ（合体）の準備**をする。
- 奇数番目の山はBへ、偶数番目の山はAに残す、など。

### Phase 3: マージ（Merge）
スタックAの先頭にある「山」と、スタックBの先頭にある「山」を比較しながら、より大きな1つの山に統合して、別の場所（Aの底やBの底）に送る。
- `A: [1, 5]`, `B: [2, 4]` → `New: [1, 2, 4, 5]`

### Phase 4: 繰り返し
山が1つ（完全にソートされた状態）になるまで、Phase2, 3を繰り返す。

---

## 3. 実装ロードマップ（ステップバイステップ）
いきなり全部作るのは無理なのため、以下の順序で実装する。

### Step 1: 「山（Run）」を見つける機能 【今回の目標】
まずは、スタックの先頭から見て 「どこまでがソートされているか」を判定する関数を作る。
- `check_sorted_length(stack)`: 先頭から何個ソートされているか数える。

### Step 2: 2つの山をマージする機能
単純に2つのスタック（AとB）のトップを比較し、小さい順（または大きい順）に並べる機能を作る。
- これができれば、事実上ソートの核が完成する。
v
### Step 3: 全体をマージするループ
Step1で見つけた山をStep2で合体させるループを作る。

---

## 4. 構造体の確認
「今扱っている山のサイズ」などは、関数の引数（`int len`）として渡せば管理できる。

```c
typedef struct s_node
{
    int             value;
    struct s_node   *pre;
    struct s_node   *next;
}               t_node;

```

---

## 5. Step 1 の実装

まずは、「今のスタックAの先頭から、何個が連番（増加列）になっているか？」を数える関数を作る。

### 作成するファイル
`srcs/sort_algorithm/find_run.c`（名前は任意）

### 実装すべき関数のイメージ

```c
/*
 * 目的: スタックの先頭から「単調増加」している長さ(Run Length)を返す
 * 例: stack [1, 5, 8, 2, ...] -> 戻り値 3 (1, 5, 8 までが増加だから)
 * 例: stack [10, 2, ...]      -> 戻り値 1 (10の次は減ってるからここで終わり)
 */
int get_run_length(t_stack *stack)
{
    // 1. スタックが空なら 0
    // 2. 現在のノード(top)とその次(next)を比較
    // 3. (current->value < next->value) である限りカウントアップ
    // 4. カウントを返す
}
```

Step 2: マージ機能の実装

やりたいこと: 
スタックAの先頭にある「ソート済みの山（長さA）」と、スタックBの先頭にある「ソート済みの山（長さB）」を、大きさ比べしながら合体させて、スタックAの底（Bottom）に送る。

イメージ: 
トランプの「スピード」や「戦争」のように、2つの手札（AとB）の一番上を見比べて、小さい方を場（Bottom）に出していく作業です。
ロジック

関数 merge_runs(t_stack *a, t_stack *b, int len_a, int len_b)

    ループ条件: 両方の山にカードが残っている間 (len_a > 0 かつ len_b > 0) 繰り返す。

    比較:

        Case 1: Aの方が小さい場合 (A->top < B->top)

            Aのカードを底に送る (ra)。

            Aの山が1つ減ったので len_a--。

        Case 2: Bの方が小さい場合 (B->top < A->top)

            BのカードをAに持ってくる (pa)。

            持ってきたカードを底に送る (ra)。

            Bの山が1つ減ったので len_b--。

    残処理: どちらかの山が尽きたら、残っている方の山を全て底に送る。

---

# Step 3: 全体をマージするループ（ソートの実行）

## 1. 目的

`merge_len_in_a` は、あくまで「準備された2つの山」を合体させるだけの関数。
これを使ってソートを完了させるには、「スタックAにある山を、順番にBに移動させて、戦わせて、勝った方を底に送る」という作業を繰り返す必要がある。

## 2. アルゴリズムの動き

ボトムアップ・マージソートの1周（パス）は、以下の流れで行う。

1. Run A の計測: スタックAの先頭にある「ソート済みの山」の長さを測る。
2. Run B の準備: スタックAの次の「ソート済みの山」を、スタックBに移動させる。
3. Merge: AとBの山を戦わせて、合体させてAの底に送る。
4. Repeat: スタックAのTopが処理済みになるまで 1〜3 を繰り返す。

### ここで発生する「反転問題」

スタック操作の宿命として、**「AからBに移動(`pb`)すると、順序が逆になる」** という問題がある。

* A: `[1, 2, 3]` (昇順)
* `pb` 3回
* B: `[3, 2, 1]` (降順)

現在の `merge_len_in_a` は「Bも昇順（Topが最小）」であることを前提としている。
そのため、このステップでは「Bに送るときに、どうやって昇順を保つか（あるいは降順を利用するか）」がカギになる。

今回はシンプルに学ぶため、まずは「移動とマージの枠組み」を作る。

---

## 3. 実装すべき関数のイメージ

`srcs/sort_algorithm/sort_loop.c` を作成し、ループ処理を記述します。

### 関数の設計図

```c
/*
 * 目的: スタックAにある「すべての山」をペアにしてマージし、
 * 1周分のソートを完了させる。
 */
void    process_one_pass(t_stack *stack_a, t_stack *stack_b)
{
    int     len_a;
    int     len_b;

    // スタックAが「未処理の山」を持っている間ループ
    // (ヒント: ここでソート済みフラグや周回数を管理する必要がありますが、
    //  まずは単純に「全要素を見る」まで回すイメージで)
    while ( /* スタックが一周するまで */ )
    {
        // 1. Aの先頭の山(Run 1)を測る
        len_a = get_asc_len(stack_a);

        // 2. 次の山(Run 2)をBに移動する
        //    (ここで Run 2 の長さを測り、その分だけ pb する)
        //    ※ ここで順序が反転することに注意！
        len_b = move_run_to_b(stack_a, stack_b);

        // 3. マージ実行
        merge_len_in_a(stack_a, stack_b, len_a, len_b);
    }
}

```

---

## 4. 次のアクション：ヘルパー関数の作成

ループの中身を完成させるために、**「山をBに移動させる関数」** が必要です。

以下の関数を `srcs/sort_algorithm/move_run.c`（新規）に実装してみる。


さらに先の工程：ループを作る

これで「1回のマージ（山2つ → 山1つ）」は完成しました。 次は、これを「スタックA全体に対して行うループ」を作ります。

このループが回るたびに、小さな三角形がたくさん合体して、少し大きな三角形になり、Aの底に溜まっていきます。
次に実装する関数 sort_one_pass

新しいファイル（例: srcs/sort_algorithm/sort_pass.c）に以下のイメージで実装します。
C

スタックAを一周して、全ての山を2倍のサイズに成長させる」 という、このソートのエンジン部分

Phase 1: 観測 (Eyes) -> get_asc/desc_len

        山の長さを測る機能。完璧です。
Phase 2: 分配 (Hands) -> move_run_to_b

        Aの「降順」を見つけてBに送り、「昇順」に変換する機能。完璧です。

Phase 3: 合体 (Zipper) -> merge_len_in_a

        AとBの山を噛み合わせてソートする機能。完璧です。
Phase 4: 周回 (One Pass) -> sort_one_pass

        スタック全体をグルっと一周処理する機能。完璧です。

残るはあと1つ、「脳（Main Loop）」だけです。 「一周回す (sort_one_pass)」を、「完全にソートされるまで繰り返す」という命令を出す親分が必要です。


### 💡 重要なヒント（次の課題）

この `move_run_to_b` を使うと、Bに移ったデータは**逆順（降順）**になります。
まずはこの関数を実装して、`main.c` で `1, 2, 3` を `move_run_to_b` したときに Bが `3, 2, 1` になる挙動を確認してください。

その挙動を確認した上で、**「じゃあどうやってマージしよう？」** という解決策（Step 4）へ進みます。

まずは `move_run.c` を作成しましょう！










---

### 3. ラストピース：Main Loop の実装


**ロジック:**

1. 「今、Aはソート済みか？」をチェック。
2. ソートされていなければ、`sort_one_pass` を実行。
3. これを繰り返す。

```c
#include "push_swap.h"

/*
 * スタックAが完全にソートされているかチェックする
 * (get_asc_lenの結果が、スタック全体のサイズと同じならソート完了！)
 */
int is_sorted(t_stack *stack)
{
    // Aの先頭からの増加列の長さ == 全体のサイズ ならOK
    if (get_asc_len(stack) == stack->size)
        return (1);
    return (0);
}

/*
 * ソート実行のメイン関数
 */
void    sort_stack(t_stack *stack_a, t_stack *stack_b)
{
    // 1. 最初からソートされていたら何もしない
    if (is_sorted(stack_a))
        return ;

    // 2. ソートされるまでパスを繰り返す
    //    1周するごとに、山のサイズが倍々になっていく
    while (!is_sorted(stack_a))
    {
        sort_one_pass(stack_a, stack_b);
    }
}

```













&nbsp;
&nbsp;

---

## 参考文献
- [うさぎでもわかるスタックとキュー](https://www.momoyama-usagi.com/entry/info-algo-stack-queue)
- [双方向連結リストとは](https://ufcpp.net/study/algorithm/col_blist.html)
&nbsp;  
&nbsp;  





---

### AIの使用について
本課題では、AIツール（Gemini Pro）を以下の通りで使用した。
### 使用したタスク
- 1
- 2
- 3

&nbsp;  
&nbsp;  

---

# 作業用メモ
- 参考記事：[うさぎでもわかるスタックとキュー（配列を使ったデータ構造）](https://www.momoyama-usagi.com/entry/info-algo-stack-queue)
- 
	- スタック  
		- ルール  
	  		LIFO (Last In, First Out) - 後に入れたものが先に出る。
		- 仕組み
	  		出入り口は「上 (top)」の1箇所のみ。
		- 特徴  
	  		データは消さずに top の位置をズラすだけで管理する（データは消さずに無視）。　　
		### 構造体：
		```c
		typedef struct	s_stack
		{
			int	elm[SIZE];
			int	top;
		}				t_stack;
		```
		### 動作
		```c
		void	push(t_stack *s, int x)
		{
		s->top += 1;
		s->elm[s->top] = x;
		}
		
		int		pop(t_stack *s)
		{
			int	out_data;

			out_data = s->elm[s->top];
			s->top -= 1;
			return (out_data);
		}
		```
	  - 実用例  
	  ChromeやFirefoxの「戻るボタン」がスタック。戻るボタンを押すと直前のページへ移動し、更に連打するとより古い履歴に遡っていく。	
	- キュー  
		- ルール  
	  		FIFO (First In, First Out) - 先に入れたものが先に出る。
		- 仕組み
	  		出入り口は「入口 (end)」と「出口 (start)」の2箇所。
		- 特徴  
	  		配列の端まで来たら、% SIZE で先頭に戻る（環状、リングキュー）。  
			start と end が重なると「空」かどうか区別できないため、count で個数を数える。
		### 構造体：
		```c
		typedef struct	s_queue
		{
			int	elm[SIZE];
			int	start;
			int	end;
			int	count;
		}				t_queue;
		```
		### 動作
		```c
		int	nextStep(int x)
		{
			return ((x + 1) % SIZE);
		}

		void	enqueue(t_queue *q, int x)
		{
			q->elm[q->end] = x;
			q->end = nextStep(q->end);
			q->count++;
		}

		int	dequeue(t_queue *q)
		{
			int	out_data;

			out_data = q->elm[q->start];
			q->start = nextStep(q->start);
			q->count--;
			return (out_data);
		}
		```
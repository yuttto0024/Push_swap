[English](#english) | [日本語](#japanese)

&nbsp;
&nbsp;

<a id="english"></a>

# Project Name (English)

_This Project has been created as part of the 42 curriculum by yuonishi_

## Table of Contents
1. [Description](#description)
2. [Project Description](#project-description)
3. [Resources](#resources)
...

## Description
(English content...)

&nbsp;  
&nbsp;  

---













<a id="japanese"></a>

# Project Name (Japanese)

_This Project has been created as part of the 42 curriculum by yuonishi_

## 目次
1. [概要](#概要)
2. [プロジェクト詳細](#プロジェクト詳細)
3. [使い方](#使い方)
3. [参考文献](#参考文献)

&nbsp;  
&nbsp;  

---

## 概要
当課題での目的は、決められたコマンドのみを用い、スタック内をソートすること。その際、可能な限り少ない操作回数でのソートを目指す。

この課題で学ぶべきこと
1. 計算量の意識  
- 普通にソートするのであれば、バブルソート等で済むが、それだと手数が増えてしまう。
- 「動けばいい」ではなく、「効率的であること」が求められる。「どうすれば無駄な動きを削減できるか」を意識する
2. 制約のある環境下でのアルゴリズム実装
- 普段であれば、「配列の何番と何番を交換」を一瞬でできるが、スタック構造では、一番上のデータしか触れない（LIFO）という制約がある。
- この不自由な環境下での、どうアルゴリズムを実装するか、という力が求められる。
3. データ構造の実践的な操作
- スタックの構造を、実際のプログラムとして動かし、データを スタックA ⇔ スタックB と移動させる処理を実装する力が求められる。

&nbsp;  
&nbsp;  

---

## プロジェクト概要
この課題では、スタックAにあるデータを、スタックBを一時領域として利用し、「限られた命令セット」のみを使用してソートするプログラムを作成する。重要な点は、ソート完了までに出力される「命令回数の最小化」である。
### データ構造の選定
ra (Rotate A) や rra (Reverse Rotate A) 等の命令は、スタックのbottomデータとtopにあるデータを操作する。このため、適切なデータ構造を選ばなければ計算コストや実装の複雑さが跳ね上がる。

&nbsp;  
&nbsp;  

---

### データ構造比較：リンクリスト vs 配列
ここでは、「リングバッファ」と「双方向リスト」を比較する。
| 比較項目 | **A. リングバッファ（循環配列）** | **B. 双方向リスト（Doubly Linked List）** |
| :--- | :--- | :--- |
| **メモリ管理** | 静的/一括確保 (`malloc` 1回)<br>メモリが連続しておりキャッシュ効率が良い。 | 動的確保 (ノード毎に `malloc`)<br>メモリが分散するため管理が必要。 |
| **Push/Pop** | Topインデックスを増減させるだけ。 | ポインタの付け替えのみ。 |
| **Rotate (`ra`)** | Top/Bottomのインデックスをズラす。<br>(中身のコピーは発生しない) | 先頭と末尾のポインタを繋ぎ変える。 |
| **実装の難所** | **インデックス計算**<br>`0`と`MAX`の境界を超える際の剰余演算 (`%`) が複雑。 | **ポインタ管理**<br>`next`, `prev` の消失やNULL参照によるセグフォ。 |
| **学習の狙い** | 配列操作、メモリ効率 | ポインタ操作、構造体、メモリ管理の基礎 |

&nbsp;  
&nbsp;  

---

### 環境構築と実装方針 (Phase 1)
1. ディレクトリ構成

保守性と再利用性を高めるため、外部ライブラリを独立したディレクトリとして配置し、再帰的なビルド環境を構築した。
Plaintext

push_swap/
├── Makefile            # ルートMakefile（各ライブラリの呼び出しとリンク）
├── includes/           # プロジェクト共通ヘッダー
├── srcs/               # ソースコード
├── libft/              # Libftライブラリ（.git削除済み）
└── ft_printf/          # ft_printfライブラリ（.git削除済み）

2. Makefile設計

    再リンク防止 (Relink protection): ソース変更がない場合はコンパイルを行わない設計。

    ライブラリ統合: libft および ft_printf をサブディレクトリのMakefileに委譲 (make -C) し、生成された .a ファイルをリンク (-L -l) する構成を採用。

3. データ構造の定義 (push_swap.h)

比較実装を行うため、以下の2つの構造体を定義済み。

    t_ring: 循環バッファ用の構造体（データ配列、top/bottomインデックス、サイズ管理）。

    t_stack (t_node): 双方向リスト用の構造体（値、next/prevポインタ）。

---





### ソートの選択  
以下、「ボトムアップ型マージソート」 を push_swap で実装するための、設計書兼手順書 を作成した。

## 1. 目的とコンセプト

### 目的

- ランダムな数値の列を、O(NlogN) の計算量でソートする。
- 「すでに部分的にソートされている箇所」 を活用して、効率よく並べ替える。

### コンセプト：自然マージソート（Natural Merge Sort）

再帰（上から分割）ではなく、**「足元にある小さな山（ソート済みの列）」を見つけて、それを合体（マージ）させていく** 手法です。

> **イメージ:**
> トランプのカードがバラバラに配られました。よく見ると「3, 4, 5」とか「10, 11」みたいに、**偶然揃っている部分**がいくつかありますよね？
> それらを崩さずに利用して、最終的に全部を1つの順番にする方法です。

---

## 2. アルゴリズムの全体像（4つのフェーズ）
このアルゴリズムは、以下の繰り返しで進みます。

### Phase 1: ラン（Run）の検出と分離
スタックAを上から見ていき、「単調増加」または「単調減少」の部分を見つけて、それをひとまとめ（1つの山）として扱う。

* 例: `[1, 5, 8, 2, 4, 10]`
* 山1: `1, 5, 8`
* 山2: `2, 4, 10`



### Phase 2: 初期分配（Distribution）
見つけた「山」を、スタックBに移動させたり、スタックAに残したりして、**マージ（合体）の準備**をする。
- 奇数番目の山はBへ、偶数番目の山はAに残す、など。

### Phase 3: マージ（Merge）
スタックAの先頭にある「山」と、スタックBの先頭にある「山」を比較しながら、より大きな1つの山に統合して、別の場所（Aの底やBの底）に送る。
- `A: [1, 5]`, `B: [2, 4]` → `New: [1, 2, 4, 5]`

### Phase 4: 繰り返し
山が1つ（完全にソートされた状態）になるまで、Phase2, 3を繰り返す。

---

## 3. 実装ロードマップ（ステップバイステップ）
いきなり全部作るのは無理なのため、以下の順序で実装する。

### Step 1: 「山（Run）」を見つける機能 【今回の目標】
まずは、スタックの先頭から見て 「どこまでがソートされているか」を判定する関数を作る。
- `check_sorted_length(stack)`: 先頭から何個ソートされているか数える。

### Step 2: 2つの山をマージする機能
単純に2つのスタック（AとB）のトップを比較し、小さい順（または大きい順）に並べる機能を作る。
- これができれば、事実上ソートの核が完成する。
v
### Step 3: 全体をマージするループ
Step1で見つけた山をStep2で合体させるループを作る。

---

## 4. 構造体の確認
「今扱っている山のサイズ」などは、関数の引数（`int len`）として渡せば管理できる。

```c
typedef struct s_node
{
    int             value;
    struct s_node   *pre;
    struct s_node   *next;
}               t_node;

```

---

## 5. Step 1 の実装

まずは、「今のスタックAの先頭から、何個が連番（増加列）になっているか？」を数える関数を作る。

### 作成するファイル
`srcs/sort_algorithm/find_run.c`（名前は任意）

### 実装すべき関数のイメージ

```c
/*
 * 目的: スタックの先頭から「単調増加」している長さ(Run Length)を返す
 * 例: stack [1, 5, 8, 2, ...] -> 戻り値 3 (1, 5, 8 までが増加だから)
 * 例: stack [10, 2, ...]      -> 戻り値 1 (10の次は減ってるからここで終わり)
 */
int get_run_length(t_stack *stack)
{
    // 1. スタックが空なら 0
    // 2. 現在のノード(top)とその次(next)を比較
    // 3. (current->value < next->value) である限りカウントアップ
    // 4. カウントを返す
}
```

Step 2: マージ機能の実装

やりたいこと: 
スタックAの先頭にある「ソート済みの山（長さA）」と、スタックBの先頭にある「ソート済みの山（長さB）」を、大きさ比べしながら合体させて、スタックAの底（Bottom）に送る。

イメージ: 
トランプの「スピード」や「戦争」のように、2つの手札（AとB）の一番上を見比べて、小さい方を場（Bottom）に出していく作業です。
ロジック

関数 merge_runs(t_stack *a, t_stack *b, int len_a, int len_b)

    ループ条件: 両方の山にカードが残っている間 (len_a > 0 かつ len_b > 0) 繰り返す。

    比較:

        Case 1: Aの方が小さい場合 (A->top < B->top)

            Aのカードを底に送る (ra)。

            Aの山が1つ減ったので len_a--。

        Case 2: Bの方が小さい場合 (B->top < A->top)

            BのカードをAに持ってくる (pa)。

            持ってきたカードを底に送る (ra)。

            Bの山が1つ減ったので len_b--。

    残処理: どちらかの山が尽きたら、残っている方の山を全て底に送る。

---

# Step 3: 全体をマージするループ（ソートの実行）

## 1. 目的

`merge_len_in_a` は、あくまで「準備された2つの山」を合体させるだけの関数。
これを使ってソートを完了させるには、「スタックAにある山を、順番にBに移動させて、戦わせて、勝った方を底に送る」という作業を繰り返す必要がある。

## 2. アルゴリズムの動き

ボトムアップ・マージソートの1周（パス）は、以下の流れで行う。

1. Run A の計測: スタックAの先頭にある「ソート済みの山」の長さを測る。
2. Run B の準備: スタックAの次の「ソート済みの山」を、スタックBに移動させる。
3. Merge: AとBの山を戦わせて、合体させてAの底に送る。
4. Repeat: スタックAのTopが処理済みになるまで 1〜3 を繰り返す。

### ここで発生する「反転問題」

スタック操作の宿命として、**「AからBに移動(`pb`)すると、順序が逆になる」** という問題がある。

* A: `[1, 2, 3]` (昇順)
* `pb` 3回
* B: `[3, 2, 1]` (降順)

現在の `merge_len_in_a` は「Bも昇順（Topが最小）」であることを前提としている。
そのため、このステップでは「Bに送るときに、どうやって昇順を保つか（あるいは降順を利用するか）」がカギになる。

今回はシンプルに学ぶため、まずは「移動とマージの枠組み」を作る。

---

ココまでで以下
  yuonishi  …/Push_swap   master 
>> ARG=$(seq 1 100 | shuf | tr '\n' ' '); ./push_swap $ARG | wc -l
1746

  yuonishi  …/Push_swap   master 
>> ARG=$(seq 1 500 | shuf | tr '\n' ' '); ./push_swap $ARG | wc -l
10743

のため、最適化を行う

## 1. 挿入ソートの実装





---


ご要望にお応えし、**「自然マージソート（Natural Merge Sort）」** から始まったこのプロジェクトの変遷を、なぜその選択をし、なぜ壁にぶつかったのかが分かるように時系列でまとめました。

---

# Push_swap アルゴリズム改善の全履歴

このプロジェクトの真の敵は、計算時間ではなく**「スタック操作のコスト（特に回転）」**でした。これに気づくまでの物語です。

## 📅 Phase 1: 自然マージソート (Natural Merge Sort)

**「元々の並びを活かしたい」という直感的なスタート**

* **戦略:**
* 入力データの中に、最初からソートされている部分列（Run）を探す（例: `3, 5, 6` ... `1, 2`）。
* それらのRunをスタックBを使ってマージし、より長いRunにしていく。


* **結果:** **約 2000回以上** (N=100)
* **敗因:** **「底へのアクセス権がない」**
* マージソートは「2つの列の先頭を比較して、小さい方を**新しい列の最後尾**に置く」作業です。
* 配列なら `arr[i] = val` で一瞬ですが、スタックで「最後尾（Bottom）」に置くには、`ra`（回転）して底に送り込まなければなりません。
* 100個のデータをマージするたびに、ほぼ100回の回転が発生。これが致命的でした。



⬇️ *「マージの回数自体を減らせばいいのでは？」*

## 📅 Phase 2: TimSort / ハイブリッド挿入ソート

**「初期Runを無理やり大きくして、マージ回数を減らす」**

* **戦略:**
* 自然な並びに頼らず、最初の段階で「サイズ25〜30のソート済みブロック」を強制的に作る（挿入ソート）。
* Runの数が減るので、マージする回数（パス数）も減るはず。


* **結果:** **約 1200〜1600回** (N=100)
* **状況:**
* 確かにマージの「回数」は減った。
* しかし、挿入ソートで作ったブロックを**「マージして結合する」瞬間の回転コスト（底送り）**はどうしても消せなかった。
* `ra`（Aの回転）と `rb`（Bの回転）を個別に実行しており、無駄が多かった。



⬇️ *「マージ（整列維持）へのこだわりを捨てよう。コスト計算だ」*

## 📅 Phase 3: コスト計算型 Greedy (現在のアルゴリズム)

**「整列の美しさより、命令数の安さを優先する」**

* **戦略:**
* **分割:** ざっくりと「平均より小さいグループ」「大きいグループ」に分けてBに送る（この時点では順序は適当でいい）。
* **計算:** Bにある全ての要素について、**「今、Aの正しい位置に戻るために何手必要か？」**を全員分シミュレーションする。
* **実行:** 最も安く済む要素（MVP）だけを実際に動かす。


* **結果:** **約 580〜630回** (N=100) 🏆
* **勝因:** **「同時回転 (rr / rrr) の最大活用」**
* マージソートは構造上、`ra` と `rb` を別々に打つことが多いです（Aを回して底へ、など）。
* このアルゴリズムは、「AもBも同じ方向に回すタイミング」を狙って移動させるため、1回の命令で2つのスタックを操作でき、コストが激減しました。



---

## 📊 スコア推移と構造の比較

| アルゴリズム | 思考の重点 | N=100 命令数 | 致命的な弱点 |
| --- | --- | --- | --- |
| **1. 自然マージ** | 「データ構造の綺麗さ」 | ~2000 | 全要素を底に送るための `ra` が多すぎる |
| **2. TimSort風** | 「マージ回数の削減」 | ~1400 | Run生成コストと、結局マージ時の `ra` が残る |
| **3. コスト計算** | **「命令数の節約」** | **~600** | なし。`rr`/`rrr` をフル活用できる |

**結論:**
「マージソート」は配列操作やリンクドリストでは最強ですが、**「回転にコストがかかるスタック」においては、計算で最短手を探すGreedy法が正解**でした。私たちは遠回りしましたが、ボトルネック（回転コスト）を一つずつ潰した結果、ここに辿り着きました。


---







&nbsp;
&nbsp;

---

## 参考文献
- [うさぎでもわかるスタックとキュー](https://www.momoyama-usagi.com/entry/info-algo-stack-queue)
- [双方向連結リストとは](https://ufcpp.net/study/algorithm/col_blist.html)
&nbsp;  
&nbsp;  





---

### AIの使用について
本課題では、AIツール（Gemini Pro）を以下の通りで使用した。
### 使用したタスク
- 1
- 2
- 3

&nbsp;  
&nbsp;  

---

# 作業用メモ
- 参考記事：[うさぎでもわかるスタックとキュー（配列を使ったデータ構造）](https://www.momoyama-usagi.com/entry/info-algo-stack-queue)
- 
	- スタック  
		- ルール  
	  		LIFO (Last In, First Out) - 後に入れたものが先に出る。
		- 仕組み
	  		出入り口は「上 (top)」の1箇所のみ。
		- 特徴  
	  		データは消さずに top の位置をズラすだけで管理する（データは消さずに無視）。　　
		### 構造体：
		```c
		typedef struct	s_stack
		{
			int	elm[SIZE];
			int	top;
		}				t_stack;
		```
		### 動作
		```c
		void	push(t_stack *s, int x)
		{
		s->top += 1;
		s->elm[s->top] = x;
		}
		
		int		pop(t_stack *s)
		{
			int	out_data;

			out_data = s->elm[s->top];
			s->top -= 1;
			return (out_data);
		}
		```
	  - 実用例  
	  ChromeやFirefoxの「戻るボタン」がスタック。戻るボタンを押すと直前のページへ移動し、更に連打するとより古い履歴に遡っていく。	
	- キュー  
		- ルール  
	  		FIFO (First In, First Out) - 先に入れたものが先に出る。
		- 仕組み
	  		出入り口は「入口 (end)」と「出口 (start)」の2箇所。
		- 特徴  
	  		配列の端まで来たら、% SIZE で先頭に戻る（環状、リングキュー）。  
			start と end が重なると「空」かどうか区別できないため、count で個数を数える。
		### 構造体：
		```c
		typedef struct	s_queue
		{
			int	elm[SIZE];
			int	start;
			int	end;
			int	count;
		}				t_queue;
		```
		### 動作
		```c
		int	nextStep(int x)
		{
			return ((x + 1) % SIZE);
		}

		void	enqueue(t_queue *q, int x)
		{
			q->elm[q->end] = x;
			q->end = nextStep(q->end);
			q->count++;
		}

		int	dequeue(t_queue *q)
		{
			int	out_data;

			out_data = q->elm[q->start];
			q->start = nextStep(q->start);
			q->count--;
			return (out_data);
		}
		```